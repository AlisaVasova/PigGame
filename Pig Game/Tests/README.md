# Тесты

## Блочные тесты
Метод  Dice.__init__ - инициирует экземпляр класса Dice

Аргументы: self - экземпляр класса, в котором выполняется данный метод

 1. Тест ```test_init_dice()``` (инициализация)
  - Входные данные: отсутствуют
  - Ожидаемый результат: свойство num_roll созданного класса равно 0

Метод  Dice.roll_die - имитирует бросание кости

Аргументы: self - экземпляр класса, в котором выполняется данный метод

 1. Тест ```test_roll_die()``` ()
  - Входные данные: self = экземпляр класса Dice
  - Ожидаемый результат: свойство num_roll созданного класса равно 0

Метод  Player.__init__ - инициирует экземпляр класса Player

Аргументы: self - экземпляр класса, в котором выполняется данный метод, name - имя пользователя, order - порядковый номер

 1. Тест ```test_player_init()``` (инициализация)
  - Входные данные: name = "Alice", order = 3
  - Ожидаемый результат: свойство name созданного класса равно "Alice", свойство order созданного класса равно 3, свойство score созданного класса равно 0

 2. Тест ```test_player_init_negativ()``` (негативный - неверные входные данные)
  - Входные данные: name = None, order = None
  - Ожидаемый результат: свойство name созданного класса равно None, свойство order созданного класса равно None, свойство score созданного класса равно 0
  
Метод Player.point_counter - увеличивает количество очков пользователя

Аргументы: self - экземпляр класса, в котором выполняется данный метод, points - количество прибавляемых очков

 1. Тест ```test_counter()``` (инициализация)
  - Входные данные: self = экземпляр класса Player со свойством score равным 0, points = 3
  - Ожидаемый результат: свойство score класса self равно 3

 2. Тест ```test_counter_negativ()``` (негативный - неверные входные данные)
  - Входные данные: self = экземпляр класса Player со свойством score равным 0, points = None
  - Ожидаемый результат: свойство score класса self не изменилось и равно 0
  
Метод  AIPlayer.__init__ - инициирует экземпляр класса AIPlayer

Аргументы: self - экземпляр класса, в котором выполняется данный метод, order - порядковый номер

 1. Тест ```test_aiplayer_init_with_order()``` (инициализация)
  - Входные данные: order = 3
  - Ожидаемый результат: свойство name созданного класса равно 'computer', свойство order созданного класса равно 3, свойство score созданного класса равно 0,  свойство aggressiveness созданного класса <=3 и >=1

 2. Тест ```test_player_init_with_no_order()``` (негативный - неверные входные данные)
  - Входные данные: order = None
  - Ожидаемый результат: свойство name созданного класса равно 'computer', свойство order созданного класса равно None, свойство score созданного класса равно 0,  свойство aggressiveness созданного класса <=3 и >=1
  
Метод Player.roll_again - высчитывает, забирает ли компьютерный игрок очки или продолжает набирать

Аргументы: self - экземпляр класса, в котором выполняется данный метод, turn_score - число набранных очков, roll_counter - число ходов, win_score - число очков для победы

 1. Тест ```test_roll_again_more_than_win_score()``` (сумма очков больше необходимого для победы)
  - Входные данные: self = экземпляр класса Player со свойством score равным 23, turn_score = 12, roll_counter = 2, win_score = 30
  - Ожидаемый результат: False

 2. Тест ```test_roll_again_aggr1()``` (агрессивность компьютерного игрока равна 1)
  - Входные данные: self = экземпляр класса Player со свойством score равным 5 и свойством aggressiveness равным 1, turn_score = 10, roll_counter = 3, win_score = 30
  - Ожидаемый результат: True
 
 3. Тест ```test_roll_again_aggr2()``` (агрессивность компьютерного игрока равна 2)
  - Входные данные: self = экземпляр класса Player со свойством score равным 5 и свойством aggressiveness равным 2, turn_score = 14, roll_counter = 3, win_score = 30
  - Ожидаемый результат: True
  
 4. Тест ```test_roll_again_aggr3()``` (агрессивность компьютерного игрока равна 3)
  - Входные данные: self = экземпляр класса Player со свойством score равным 5 и свойством aggressiveness равным 3, turn_score = 20, roll_counter = 4, win_score = 30
  - Ожидаемый результат: True
  
 5. Тест ```test_roll_again_big_score()``` (при любой агрессивности число набранных очков достаточно велико для забирания)
  - Входные данные: self = экземпляр класса Player со свойством score равным 5, turn_score = 22, roll_counter = 5, win_score = 30
  - Ожидаемый результат: False

 6. Тест ```test_roll_again_negtiv()``` (негативный - неверные входные данные)
  - Входные данные: self = экземпляр класса Player со свойством score равным 5, turn_score = None, roll_counter = "", win_score = None
  - Ожидаемый результат: None

Метод Player.__more_than_win_score - высчитывает, забирает ли компьютерный игрок очки или продолжает набирать

Аргументы: self - экземпляр класса, в котором выполняется данный метод, add_score - число добавляемых очков, win_score - число очков для победы


## Интеграционные тесты 

Функция decision() вызывает функции is_there_solution(), ved_stolbec(), ved_stroka(), preobr()

Аргументы: basis - номера переменных, входящие в базис, bdr - столбец БДР, array - массив с коэффициентами переменных при ограничениях, n - количество переменных, m - количество органичений, cel_func - коэффициенты переменных при целевой функции, delts - строка оценок

1. Тест ```test_is_decision``` (есть решение для данной задачи)
  - Входные данные: basis = [2, 4], bdr = [4, 14], array = [[1, 0, 2, 1],[4, 1, 6, 0]], n = 4, m = 2, cel_func = [1, 2, 0, 3], delts = [0,0,0,0]
  - Ожидаемый результат: True
  
2. Тест ```test_is_not_decision``` (нет решения для данной задачи)
  - Входные данные: basis = [2, 4], bdr = [10, 40], array = [[1, -1, 1, 0],[2, 0, 0, 1]], n = 4, m = 2, cel_func = [-1, -2, 0, 0], delts = [0,0,0,0]
  - Ожидаемый результат: False, [1, 2], [3, 1], [[0,-0.5,1,2],[1,1,0,-3]]

Функция reverse_transition() вызывает функцию preobr():

Аргументы: array_dop - массив с коэффициентами переменных при ограничениях, n_dop - количество переменных c искусственными, n - количество переменных без искусственных, m - количество органичений, basis_dop - номера переменных, входящие в базис, bdr_dop - столбец БДР

1. Тест ```test_intgr_reverse_in_basis_not_art``` (когда в базисе нет искусственных переменных)
 - Входные данные: n = 4, m = 3, array_dop = [[0,1,0,0,2,-1],[0,0,1,-1,-4,3],[1,0,0,1,-3,2]], n_dop = 6, bdr_dop = [0,5,2], basis_dop = [2,3,1]
 - Ожидаемый результат: [0,5,2], [[0,1,0,0],[0,0,1,-1],[1,0,0,1]], [2,3,1]
 
2. Тест ```test_intgr_reverse_in_basis_is_art``` (когда в базисе есть искусственные переменные)
 - Входные данные: n = 3, m = 2, array_dop = [[2,0,1,1],[6,1,4,0]], n_dop = 4, bdr_dop = [4,14], basis_dop = [4,2]
 - Ожидаемый результат: [2,2], [[1,0,0.5,0.5],[0,1,1,-3]], [1,2]

Функция main() вызывает функции input_model(), find_basis(), count_mis_vars(), decision(), artificial_basis(), reverse_transition():

1. Тест ```test_main_with_art_basis``` - когда используется метод искусственного базиса
 - Входные данные: ["4", "3", "3", "1", "1", "0", "1", "2", "0", "1", "2", "-2", "-1", "1", "-3", "1", "2", "3", "0", "2", "4"]
 - Ожидаемый результат: в базисе находятся переменные 2,3,4; им соответствуют значения БДР 0,7,2

2. Тест ```test_main'`` - когда не используется метод искусственного базиса
 - Входные данные: ["4", "2", "1", "2", "0", "3", "1", "0", "2", "1", "4", "4", "1", "6", "0", "14"]
 - Ожидаемый результат: в базисе находятся переменные 1,3; им соответствуют значения БДР 2,1

## Аттестационные тесты 

1. Тест 1 - проверка запуска программы
 - Действия: пользователь запускает программу
 - Ожидаемый результат: программа запрашивает количество переменных
 
2. Тест 2 - проверка ввода количества переменных и ограничений (положительная)
 - Действия: пользователь вводит целое число > 0
 - Ожидаемый результат: программа запрашивает следующее число

3. Тест 3 - проверка ввода количества переменных и ограничений (отрицательная)
 - Действия: пользователь вводит не число, нецелое число или целое число <= 0
 - Ожидаемый результат: программа выводит сообщение об ошибке и запрашивает данные еще раз

4. Тест 4 - проверка ввода коэффициентов ограничений (положительная)
 - Действия: пользователь вводит число
 - Ожидаемый результат: программа запрашивает следующее число

5. Тест 5 - проверка ввода коэффициентов ограничений (отрицательная)
 - Действия: пользователь вводит не число
 - Ожидаемый результат: программа выводит сообщение об ошибке и запрашивает данные еще раз
 
6. Тест 6 - проверка нахождения решения
  - Действия: пользователь вводит "4", "3", "3", "1", "1", "0", "1", "2", "0", "1", "2", "-2", "-1", "1", "-3", "1", "2", "3", "0", "2", "4"
  - Ожидаемый результат: программа выводит процесс решения в таблицах и находит решение: в базисе находятся переменные 2,3,4; им соответствуют значения БДР 0,7,2

7. Тест 7 - проверка отсутствия решения
  - Действия: пользователь вводит "4", "2", "1", "-1", "1", "0", "10", "2", "0", "0", "1", "40"
  - Ожидаемый результат: программа выводит процесс решения в таблицах и то, что нет решения
